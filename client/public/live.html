<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Paper Trading Live</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Paper Trading</h1>
  <form id="cfg">
    <label>TP %: <input step="0.0001" type="number" id="tpPct"></label>
    <label>SL %: <input step="0.0001" type="number" id="slPct"></label>
    <label>Trail %: <input step="0.0001" type="number" id="trailPct"></label>
    <label>Risk %: <input step="0.0001" type="number" id="riskPct"></label>
    <label>Max open: <input step="1" type="number" id="maxOpenTrades"></label>
    <label><input type="checkbox" id="muteAlerts"> Mute Telegram alerts</label>
    <button type="submit">Save</button>
  </form>
  <button onclick="fetch('/live/start',{method:'POST'})">Start</button>
  <button onclick="fetch('/live/stop',{method:'POST'})">Stop</button>
  <button onclick="fetch('/live/trades',{method:'DELETE'})">Reset</button>

  <h2>Open Positions</h2>
  <table border="1"><thead><tr><th>Time</th><th>Entry</th><th>Size</th></tr></thead><tbody id="openBody"></tbody></table>

  <h2>Equity</h2>
  <canvas id="chart"></canvas>

  <h2>Trades</h2>
  <table border="1"><thead><tr><th>Time</th><th>Entry</th><th>Exit</th><th>PnL</th></tr></thead><tbody id="tbody"></tbody></table>
  <h2>Real Trades</h2>
  <form id="histForm">
    <label>From: <input type="date" id="histFrom"></label>
    <label>To: <input type="date" id="histTo"></label>
    <button type="button" id="histLoadBtn">Load</button>
  </form>
  <canvas id="realEquityChart" width="600" height="200"></canvas>
  <table id="realTradesTable" border="1"><thead><tr><th>Time</th><th>Entry</th><th>Exit</th><th>PnL</th></tr></thead><tbody></tbody></table>

  <section class="card">
    <h2>Real-time equity (DB)</h2>

    <div class="row">
      <label>From:
        <input type="date" id="dbFrom">
      </label>
      <button id="dbConnectBtn">Connect</button>
      <button id="dbDisconnectBtn" disabled>Disconnect</button>
    </div>

    <canvas id="dbEquityChart" width="900" height="300" style="border:1px solid #ddd;"></canvas>
    <div id="dbEquityStats" class="muted" style="margin-top:8px;"></div>
  </section>

  <script>
async function loadCfg() {
  const c = await fetch('/live/config').then(r=>r.json());
  tpPct.value = c.tpPct; slPct.value = c.slPct; trailPct.value = c.trailPct;
  riskPct.value = c.riskPct; maxOpenTrades.value = c.maxOpenTrades;
  muteAlerts.checked = !!c.muteAlerts;
}
document.getElementById('cfg').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const body = {
    tpPct: Number(tpPct.value),
    slPct: Number(slPct.value),
    trailPct: Number(trailPct.value),
    riskPct: Number(riskPct.value),
    maxOpenTrades: Number(maxOpenTrades.value),
    muteAlerts: !!muteAlerts.checked
  };
  await fetch('/live/config',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
  alert('Saved!');
});

async function refresh() {
  const data = await fetch('/live').then(r=>r.json());
  const openBody = document.getElementById('openBody');
  openBody.innerHTML = '';
  (data.openPositions || []).forEach(p=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${new Date(p.ts).toISOString()}</td><td>${p.entry_price}</td><td>${p.size}</td>`;
    openBody.appendChild(tr);
  });
  const tbody = document.getElementById('tbody');
  tbody.innerHTML = '';
  (data.trades || []).slice(-10).forEach(t=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${new Date(t.ts).toISOString()}</td><td>${t.entry_price}</td><td>${t.exit_price??''}</td><td>${t.pnl??''}</td>`;
    tbody.appendChild(tr);
  });
  chart.data.labels = data.trades.map(t=>new Date(t.ts).toLocaleTimeString());
  chart.data.datasets[0].data = data.trades.map((t,i)=>10000+(data.trades.slice(0,i+1).map(x=>x.pnl||0).reduce((a,b)=>a+b,0)));
  chart.update();
}
const ctx = document.getElementById('chart');
const chart = new Chart(ctx,{type:'line',data:{labels:[],datasets:[{label:'Equity',data:[]}]},options:{responsive:true}});
setInterval(refresh,5000);
loadCfg();
refresh();

async function loadRealHistory() {
  const params = new URLSearchParams();
  if (histFrom.value) params.append('from', histFrom.value);
  if (histTo.value) params.append('to', histTo.value);
  const res = await fetch('/live/history?' + params.toString());
  const data = await res.json();
  const tbody = document.querySelector('#realTradesTable tbody');
  tbody.innerHTML = '';
  (data.trades || []).forEach(t => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${new Date(t.ts).toISOString()}</td><td>${t.entry_price}</td><td>${t.exit_price}</td><td>${t.pnl}</td>`;
    tbody.appendChild(tr);
  });
  drawRealEquity(data.equity || []);
}

function drawRealEquity(points) {
  const c = document.getElementById('realEquityChart');
  const ctx = c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);
  if (!points.length) return;
  const minTs = points[0].ts;
  const maxTs = points[points.length - 1].ts;
  let minEq = Math.min(...points.map(p=>p.equity));
  let maxEq = Math.max(...points.map(p=>p.equity));
  if (maxEq === minEq) { minEq -= 1; maxEq += 1; }
  ctx.beginPath();
  points.forEach((p,i) => {
    const x = maxTs === minTs ? 0 : (p.ts - minTs) / (maxTs - minTs) * c.width;
    const y = c.height - (p.equity - minEq) / (maxEq - minEq) * c.height;
    if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();
}

document.getElementById('histLoadBtn').addEventListener('click', loadRealHistory);
loadRealHistory();
  </script>

  <script>
(function() {
  const cvs = document.getElementById('dbEquityChart');
  const ctx = cvs.getContext('2d');
  const statsEl = document.getElementById('dbEquityStats');
  const fromEl = document.getElementById('dbFrom');
  const btnConnect = document.getElementById('dbConnectBtn');
  const btnDisconnect = document.getElementById('dbDisconnectBtn');

  let evtSrc = null;     // EventSource
  let points = [];       // {ts, equity}
  let minX=0, maxX=1, minY=0, maxY=1;

  function isoDateToInput(ms) {
    const d = new Date(ms);
    return d.toISOString().slice(0,10);
  }

  function fitBounds() {
    if (!points.length) { minX=0; maxX=1; minY=0; maxY=1; return; }
    minX = points[0].ts;
    maxX = points[points.length - 1].ts;
    minY = Math.min(...points.map(p => p.equity));
    maxY = Math.max(...points.map(p => p.equity));
    if (minY === maxY) { minY -= 1; maxY += 1; }
    if (minX === maxX) { minX -= 1; maxX += 1; }
  }

  function draw() {
    ctx.clearRect(0,0,cvs.width,cvs.height);
    if (!points.length) return;
    fitBounds();
    const pad = 30;
    const W = cvs.width - pad*2;
    const H = cvs.height - pad*2;
    const xTo = (x) => pad + (x - minX) / (maxX - minX) * W;
    const yTo = (y) => pad + (maxY - y) / (maxY - minY) * H;

    // axes
    ctx.beginPath();
    ctx.moveTo(pad, pad);
    ctx.lineTo(pad, pad + H);
    ctx.lineTo(pad + W, pad + H);
    ctx.stroke();

    // line
    ctx.beginPath();
    for (let i=0;i<points.length;i++) {
      const p = points[i];
      const x = xTo(p.ts);
      const y = yTo(p.equity);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  function setStats() {
    if (!points.length) { statsEl.textContent = 'No data'; return; }
    let peak = -Infinity, maxDD = 0;
    for (const p of points) {
      if (p.equity > peak) peak = p.equity;
      const dd = peak - p.equity;
      if (dd > maxDD) maxDD = dd;
    }
    const last = points[points.length - 1].equity;
    statsEl.textContent = `Points: ${points.length} | Equity: ${last.toFixed(2)} | MaxDD: ${maxDD.toFixed(2)}`;
  }

  function connect() {
    const params = [];
    if (fromEl.value) params.push(`from=${encodeURIComponent(fromEl.value)}`);
    const url = params.length ? `/live/equity-stream?${params.join('&')}` : '/live/equity-stream';
    evtSrc = new EventSource(url);

    evtSrc.onmessage = (ev) => {
      const data = JSON.parse(ev.data);
      if (data.type === 'init') {
        points = data.equity || [];
        draw();
        setStats();
      } else if (data.type === 'append' && data.point) {
        points.push(data.point);
        draw();
        setStats();
      }
    };

    evtSrc.onerror = () => {
      // Silent – browser will retry
    };

    btnConnect.disabled = true;
    btnDisconnect.disabled = false;
  }

  function disconnect() {
    if (evtSrc) { evtSrc.close(); evtSrc = null; }
    btnConnect.disabled = false;
    btnDisconnect.disabled = true;
  }

  // init UI
  const now = Date.now();
  fromEl.value = isoDateToInput(now - 7*24*3600*1000); // default – paskutinės 7 d.

  btnConnect.addEventListener('click', connect);
  btnDisconnect.addEventListener('click', disconnect);

})();
  </script>
</body>
</html>
