<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Paper Trading Live</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Paper Trading</h1>
  <section id="risk">
    <h2>Risk</h2>
    <div>Status: <span id="riskState">...</span>
      <button id="riskHaltBtn">HALT</button>
      <button id="riskResumeBtn">RESUME</button>
    </div>
    <div>Daily P/L: <progress id="dailyLossBar" value="0" max="100"></progress></div>
    <ul id="riskLog"></ul>
  </section>
  <section id="userStream">
    <h2>User Data Stream</h2>
    <div>Stream status: <span id="udsState">disconnected</span> <button id="udsReconnect">Reconnect</button></div>
    <h3>Orders</h3>
    <table border="1" id="udsOrders">
      <thead><tr><th>Time</th><th>Symbol</th><th>Side</th><th>Status</th><th>LastQty</th><th>LastPrice</th><th>CumQty</th><th>AvgPrice</th><th>RealizedPnL</th></tr></thead>
      <tbody></tbody>
    </table>
    <h3>Account</h3>
    <pre id="udsAccount"></pre>
    <h3>Positions</h3>
    <pre id="udsPositions"></pre>
  </section>
  <section id="binance">
    <h2>Binance Testnet</h2>
    <button id="pingBtn">Ping</button> <span id="pingRes"></span>
    <div>
      <button id="accountBtn">Account</button>
      <pre id="accountOut" style="white-space:pre-wrap"></pre>
    </div>
    <h3>Test Order</h3>
    <form id="orderForm">
      <input name="symbol" placeholder="BTCUSDT">
      <select name="side"><option>BUY</option><option>SELL</option></select>
      <select name="type"><option>MARKET</option><option>LIMIT</option></select>
      <input name="quantity" type="number" step="0.0001" placeholder="qty">
      <input name="price" type="number" step="0.01" placeholder="price">
      <label><input type="checkbox" name="dryRun" checked> Dry Run</label>
      <button type="submit">Send</button>
    </form>
    <pre id="orderRes" style="white-space:pre-wrap"></pre>
  </section>
  <form id="cfg">
    <label>TP %: <input step="0.0001" type="number" id="tpPct"></label>
    <label>SL %: <input step="0.0001" type="number" id="slPct"></label>
    <label>Trail %: <input step="0.0001" type="number" id="trailPct"></label>
    <label>Risk %: <input step="0.0001" type="number" id="riskPct"></label>
    <label>Max open: <input step="1" type="number" id="maxOpenTrades"></label>
    <label><input type="checkbox" id="muteAlerts"> Mute Telegram alerts</label>
    <button type="submit">Save</button>
  </form>
  <button onclick="fetch('/live/start',{method:'POST'})">Start</button>
  <button onclick="fetch('/live/stop',{method:'POST'})">Stop</button>
  <button onclick="fetch('/live/trades',{method:'DELETE'})">Reset</button>

  <h2>Open Positions</h2>
  <table border="1"><thead><tr><th>Time</th><th>Entry</th><th>Size</th></tr></thead><tbody id="openBody"></tbody></table>

  <h2>Equity</h2>
  <canvas id="chart"></canvas>

  <h2>Trades</h2>
  <table border="1"><thead><tr><th>Time</th><th>Entry</th><th>Exit</th><th>PnL</th></tr></thead><tbody id="tbody"></tbody></table>

  <h2>Closed Trades</h2>
  <div id="historyFilters">
    <label>Symbol: <input id="histSymbol"></label>
    <label>Strategy: <select id="histStrategy"></select></label>
    <label>From: <input type="datetime-local" id="histFrom"></label>
    <label>To: <input type="datetime-local" id="histTo"></label>
    <button type="button" id="histRefreshBtn">Refresh</button>
    <span id="histLoading" style="display:none;">Loading...</span>
  </div>
  <div id="histEmpty" style="display:none;">No closed trades</div>
  <div style="max-height:300px;overflow-y:auto;">
    <table id="closedTradesTable" border="1">
      <thead>
        <tr>
          <th>Closed At</th><th>Symbol</th><th>Strategy</th><th>Side</th><th>Qty</th><th>Entry</th><th>Exit</th><th>PnL</th><th>PnL %</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <section class="card">
    <h2>Real-time equity (DB)</h2>

    <div class="row">
      <label>From:
        <input type="date" id="dbFrom">
      </label>
      <button id="dbConnectBtn">Connect</button>
      <button id="dbDisconnectBtn" disabled>Disconnect</button>
    </div>

    <canvas id="dbEquityChart" width="900" height="300" style="border:1px solid #ddd;"></canvas>
    <div id="dbEquityStats" class="muted" style="margin-top:8px;"></div>
  </section>

  <script>
const pingBtn = document.getElementById('pingBtn');
pingBtn.addEventListener('click', async () => {
  const r = await fetch('/binance/ping').then(r=>r.json()).catch(e=>({ error: String(e) }));
  document.getElementById('pingRes').textContent = JSON.stringify(r);
});

document.getElementById('accountBtn').addEventListener('click', async () => {
  const r = await fetch('/binance/account').then(r=>r.json()).catch(e=>({ error: String(e) }));
  if (r && r.totalWalletBalance !== undefined) {
    const positions = (r.positions || []).filter(p => Number(p.positionAmt));
    const lines = [`Wallet: ${r.totalWalletBalance}`, `Available: ${r.availableBalance}`, 'Positions:', ...positions.map(p => `${p.symbol} ${p.positionAmt}`)];
    document.getElementById('accountOut').textContent = lines.join('\n');
  } else {
    document.getElementById('accountOut').textContent = JSON.stringify(r, null, 2);
  }
});

document.getElementById('orderForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  const f = e.target;
  const payload = {
    symbol: f.symbol.value.toUpperCase(),
    side: f.side.value,
    type: f.type.value,
    quantity: Number(f.quantity.value),
    price: f.price.value ? Number(f.price.value) : undefined,
    dryRun: f.dryRun.checked,
  };
  const r = await fetch('/binance/order', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) }).then(r=>r.json()).catch(e=>({ error: String(e) }));
  document.getElementById('orderRes').textContent = JSON.stringify(r, null, 2);
});

async function loadCfg() {
  const c = await fetch('/live/config').then(r=>r.json());
  tpPct.value = c.tpPct; slPct.value = c.slPct; trailPct.value = c.trailPct;
  riskPct.value = c.riskPct; maxOpenTrades.value = c.maxOpenTrades;
  muteAlerts.checked = !!c.muteAlerts;
}
document.getElementById('cfg').addEventListener('submit', async (e)=>{
  e.preventDefault();
  const body = {
    tpPct: Number(tpPct.value),
    slPct: Number(slPct.value),
    trailPct: Number(trailPct.value),
    riskPct: Number(riskPct.value),
    maxOpenTrades: Number(maxOpenTrades.value),
    muteAlerts: !!muteAlerts.checked
  };
  await fetch('/live/config',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
  alert('Saved!');
});

async function refresh() {
  const data = await fetch('/live').then(r=>r.json());
  const openBody = document.getElementById('openBody');
  openBody.innerHTML = '';
  (data.openPositions || []).forEach(p=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${new Date(p.ts).toISOString()}</td><td>${p.entry_price}</td><td>${p.size}</td>`;
    openBody.appendChild(tr);
  });
  const tbody = document.getElementById('tbody');
  tbody.innerHTML = '';
  (data.trades || []).slice(-10).forEach(t=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${new Date(t.ts).toISOString()}</td><td>${t.entry_price}</td><td>${t.exit_price??''}</td><td>${t.pnl??''}</td>`;
    tbody.appendChild(tr);
  });
  chart.data.labels = data.trades.map(t=>new Date(t.ts).toLocaleTimeString());
  chart.data.datasets[0].data = data.trades.map((t,i)=>10000+(data.trades.slice(0,i+1).map(x=>x.pnl||0).reduce((a,b)=>a+b,0)));
  chart.update();
}
const ctx = document.getElementById('chart');
const chart = new Chart(ctx,{type:'line',data:{labels:[],datasets:[{label:'Equity',data:[]}]},options:{responsive:true}});
setInterval(refresh,5000);
loadCfg();
refresh();

const histSymbol = document.getElementById('histSymbol');
const histStrategy = document.getElementById('histStrategy');
const histFrom = document.getElementById('histFrom');
const histTo = document.getElementById('histTo');
const histLoading = document.getElementById('histLoading');
const histEmpty = document.getElementById('histEmpty');

function formatDate(ms) {
  const d = new Date(ms);
  return d.toISOString().replace('T', ' ').slice(0,19);
}

function buildHistoryQuery() {
  const q = new URLSearchParams();
  if (histSymbol.value) q.set('symbol', histSymbol.value.trim());
  if (histStrategy.value) q.set('strategy', histStrategy.value.trim());
  if (histFrom.value) q.set('from', new Date(histFrom.value).toISOString());
  if (histTo.value) q.set('to', new Date(histTo.value).toISOString());
  return q.toString();
}

async function loadClosedTrades() {
  histLoading.style.display = 'inline';
  histEmpty.style.display = 'none';
  const qs = buildHistoryQuery();
  const res = await fetch('/live/history' + (qs ? '?' + qs : ''));
  const data = await res.json();
  histLoading.style.display = 'none';
  const tbody = document.querySelector('#closedTradesTable tbody');
  tbody.innerHTML = '';
  const trades = data.closedTrades || [];
  if (!trades.length) {
    histEmpty.style.display = 'block';
    return;
  }
  trades.slice(0,200).forEach(t => {
    const tr = document.createElement('tr');
    const pnl = t.pnl || 0;
    const pnlPct = t.pnl_pct || 0;
    tr.innerHTML = `
      <td>${t.closed_at ? formatDate(t.closed_at) : ''}</td>
      <td>${t.symbol || ''}</td>
      <td>${t.strategy || ''}</td>
      <td>${t.side || ''}</td>
      <td>${t.qty ?? ''}</td>
      <td>${t.entry_price ?? ''}</td>
      <td>${t.exit_price ?? ''}</td>
      <td style="color:${pnl>0?'green':pnl<0?'red':'inherit'}">${pnl.toFixed(2)}</td>
      <td style="color:${pnlPct>0?'green':pnlPct<0?'red':'inherit'}">${pnlPct.toFixed(2)}</td>`;
    tbody.appendChild(tr);
  });
}

document.getElementById('histRefreshBtn').addEventListener('click', loadClosedTrades);

// initial 24h load
const now = new Date();
histTo.value = new Date(now).toISOString().slice(0,16);
histFrom.value = new Date(now.getTime() - 24*60*60*1000).toISOString().slice(0,16);
async function loadStrategyOptions() {
  histStrategy.innerHTML = '<option value="">All</option>';
  try {
    const arr = await fetch('/strategies').then(r => r.json());
    arr.forEach(s => {
      const opt = document.createElement('option');
      opt.value = s.id;
      opt.textContent = s.label || s.id;
      histStrategy.appendChild(opt);
    });
  } catch {}
}

loadStrategyOptions().then(loadClosedTrades);
setInterval(loadClosedTrades, 30000);
  </script>
  <script>
  (function() {
    const stateEl = document.getElementById('udsState');
    const btn = document.getElementById('udsReconnect');
    const ordersBody = document.querySelector('#udsOrders tbody');
    const accEl = document.getElementById('udsAccount');
    const posEl = document.getElementById('udsPositions');
    let es;

    function connect() {
      stateEl.textContent = 'connecting';
      es = new EventSource('/live/user-stream');
      es.onmessage = (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.type === 'init') {
          if (msg.account) {
            accEl.textContent = JSON.stringify({ wallet: msg.account.totalWalletBalance, available: msg.account.availableBalance }, null, 2);
          }
          if (msg.positions) posEl.textContent = JSON.stringify(msg.positions, null, 2);
        } else if (msg.type === 'order') {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${new Date(msg.T).toLocaleTimeString()}</td><td>${msg.s}</td><td>${msg.S}</td><td>${msg.X}</td><td>${msg.l}</td><td>${msg.L}</td><td>${msg.z}</td><td>${msg.ap}</td><td>${msg.rp}</td>`;
          ordersBody.prepend(tr);
          while (ordersBody.children.length > 20) ordersBody.removeChild(ordersBody.lastChild);
        } else if (msg.type === 'account') {
          accEl.textContent = JSON.stringify(msg.balances || [], null, 2);
          posEl.textContent = JSON.stringify(msg.positions || [], null, 2);
        } else if (msg.type === 'status') {
          stateEl.textContent = msg.state;
        }
      };
      es.onerror = () => { stateEl.textContent = 'reconnecting'; };
    }

    btn.addEventListener('click', () => {
      if (es) es.close();
      connect();
    });

    connect();
  })();
  </script>

  <script>
(function() {
  const cvs = document.getElementById('dbEquityChart');
  const ctx = cvs.getContext('2d');
  const statsEl = document.getElementById('dbEquityStats');
  const fromEl = document.getElementById('dbFrom');
  const btnConnect = document.getElementById('dbConnectBtn');
  const btnDisconnect = document.getElementById('dbDisconnectBtn');

  let evtSrc = null;     // EventSource
  let points = [];       // {ts, equity}
  let minX=0, maxX=1, minY=0, maxY=1;

  function isoDateToInput(ms) {
    const d = new Date(ms);
    return d.toISOString().slice(0,10);
  }

  function fitBounds() {
    if (!points.length) { minX=0; maxX=1; minY=0; maxY=1; return; }
    minX = points[0].ts;
    maxX = points[points.length - 1].ts;
    minY = Math.min(...points.map(p => p.equity));
    maxY = Math.max(...points.map(p => p.equity));
    if (minY === maxY) { minY -= 1; maxY += 1; }
    if (minX === maxX) { minX -= 1; maxX += 1; }
  }

  function draw() {
    ctx.clearRect(0,0,cvs.width,cvs.height);
    if (!points.length) return;
    fitBounds();
    const pad = 30;
    const W = cvs.width - pad*2;
    const H = cvs.height - pad*2;
    const xTo = (x) => pad + (x - minX) / (maxX - minX) * W;
    const yTo = (y) => pad + (maxY - y) / (maxY - minY) * H;

    // axes
    ctx.beginPath();
    ctx.moveTo(pad, pad);
    ctx.lineTo(pad, pad + H);
    ctx.lineTo(pad + W, pad + H);
    ctx.stroke();

    // line
    ctx.beginPath();
    for (let i=0;i<points.length;i++) {
      const p = points[i];
      const x = xTo(p.ts);
      const y = yTo(p.equity);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  function setStats() {
    if (!points.length) { statsEl.textContent = 'No data'; return; }
    let peak = -Infinity, maxDD = 0;
    for (const p of points) {
      if (p.equity > peak) peak = p.equity;
      const dd = peak - p.equity;
      if (dd > maxDD) maxDD = dd;
    }
    const last = points[points.length - 1].equity;
    statsEl.textContent = `Points: ${points.length} | Equity: ${last.toFixed(2)} | MaxDD: ${maxDD.toFixed(2)}`;
  }

  function connect() {
    const params = [];
    if (fromEl.value) params.push(`from=${encodeURIComponent(fromEl.value)}`);
    const url = params.length ? `/live/equity-stream?${params.join('&')}` : '/live/equity-stream';
    evtSrc = new EventSource(url);

    evtSrc.onmessage = (ev) => {
      const data = JSON.parse(ev.data);
      if (data.type === 'init') {
        points = data.equity || [];
        draw();
        setStats();
      } else if (data.type === 'append' && data.point) {
        points.push(data.point);
        draw();
        setStats();
      }
    };

    evtSrc.onerror = () => {
      // Silent – browser will retry
    };

    btnConnect.disabled = true;
    btnDisconnect.disabled = false;
  }

  function disconnect() {
    if (evtSrc) { evtSrc.close(); evtSrc = null; }
    btnConnect.disabled = false;
    btnDisconnect.disabled = true;
  }

  // init UI
  const now = Date.now();
  fromEl.value = isoDateToInput(now - 7*24*3600*1000); // default – paskutinės 7 d.

  btnConnect.addEventListener('click', connect);
  btnDisconnect.addEventListener('click', disconnect);

})();
  </script>
  <script>
(function() {
  async function refresh() {
    const r = await fetch('/risk/status').then(r=>r.json()).catch(()=>null);
    if (!r) return;
    document.getElementById('riskState').textContent = r.state?.state || 'unknown';
    const eq = Number(r.state?.equity_day_start || 0);
    const pnl = Number(r.state?.realized_pnl_today || 0);
    const lossPct = eq ? (pnl / eq) * 100 : 0;
    const bar = document.getElementById('dailyLossBar');
    bar.max = r.config?.maxDailyLossPct || 100;
    bar.value = Math.min(Math.abs(lossPct), bar.max);
  }
  async function loadLogs() {
    const rows = await fetch('/risk/logs').then(r=>r.json()).catch(()=>[]);
    const ul = document.getElementById('riskLog');
    ul.innerHTML = '';
    rows.slice(0,10).forEach(l => {
      const li = document.createElement('li');
      li.textContent = `${l.ts} ${l.action} ${l.reason||''}`;
      ul.appendChild(li);
    });
  }
  document.getElementById('riskHaltBtn').onclick = async () => {
    await fetch('/risk/halt', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: '{}' });
    await refresh();
    await loadLogs();
  };
  document.getElementById('riskResumeBtn').onclick = async () => {
    await fetch('/risk/resume', { method: 'POST' });
    await refresh();
    await loadLogs();
  };
  refresh();
  loadLogs();
  setInterval(refresh, 10000);
})();
  </script>
</body>
</html>
